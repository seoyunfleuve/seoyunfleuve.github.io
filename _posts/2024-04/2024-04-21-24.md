---
title: 모던 리액트 Deep Dive 12장 - 모든 웹 개발자가 관심을 가져야 할 핵심 웹 지표
categories: [React, Study]
tags: [react, monthlyCs, LCP, FID, CLS]
comment: true
---

<br />

## 12장. 모든 웹 개발자가 관심을 가져야 할 핵심 웹 지표

### 12.1 웹사이트와 성능

- 사용자가 웹사이트에 기대하는 사항
  > - 웹사이트에 방문한 목적 달성
  > - 짧은 목적 달성 시간
  > - 보안

<br />

- 웹사이트의 성능과 사용자 경험 사이의 상관관계
  > - 0 ~ 5 초 범위에서 1초 로딩이 늦어질수록 구매 전환율은 4.42 % 씩 감소
  > - 페이지 로드 시간이 1초에서 10초로 늘어날수록 모바일 사이트 이탈률이 123 % 증가

<br />
<br />
<br />

### 12.2 핵심 웹 지표란?

- 핵심 웹 지표 (Core Web Vital)
  > - 구글에서 만든 지표로, 웹사이트에서 뛰어난 사용자 경험을 제공하는 데 필수적인 지표를 일컫는 용어
  > - 최대 콘텐츠풀 페인트 (LCP: Largest Contentful Paint)
  > - 최초 입력 지연 (FID: First Input Delay)
  > - 누적 레이아웃 이동 (CLS: Cumulative Layout Shift)
  > - 최초 바이트까지의 시간 (TTFB: Time To First Byte)
  > - 최초 콘텐츠풀 시간 (FCP: First Contentful Paint)

<br />
<br />
<br />

### 12.3 최대 콘텐츠풀 페인트 (LCP)

##### 12.3.1 정의

- 최대 콘텐츠풀 페인트 (LCP: Largest Contetnful Paint)
  > - 페이지가 처음으로 로드를 시작한 시점부터 뷰포트 내부에서 (사용자에게 현재 노출되는 화면) 가장 큰 이미지 또는 텍스트를 렌더링하는 데 걸리는 시간

<br />

- 뷰포트에 내부에서 큰 이미지와 텍스트
  > - img 태그
  > - svg 태그 내부의 image 태그
  > - poster 속성을 사용하는 video 태그
  > - url() 을 통해 불러온 배경 이미지가 있는 요소
  > - 텍스트와 같이 인라인 텍스트 요소를 포함하고 있는 블록 레벨 요소 (p, div 등 포함)

<br />

- 이미지와 텍스트가 각각 사용자의 시점에 언제 노출됐는지 확인하는 정확한 시점
  > - 각 엘리먼트가 등장한 시점부터 텍스트 또는 이미지가 완전히 로딩되는 시점

<br />
<br />

##### 12.3.2 의미

- 사용자가 페이지가 어느 정도 로딩됐다고 인식하는 시점
  > - 사용자에게 로딩은 뷰포트 영역에 보이는 부분을 기준
  > - 메인 콘텐츠가 화면에 완전히 전달되는 속도
  > - 최대 콘텐츠풀 페인트로 객관적 판단이 가능

<br />
<br />

##### 12.3.3 예제

- 최대 콘텐츠풀 페인트는 페이지 로딩에 따라 변화하는 지표
  > - 웹사이트에서 헤더가 가장 먼저 노출되면 최대 콘텐츠풀 페인트는 헤더, 그 다음 콘텐츠가 로딩되면 최대 콘텐츠풀 페인트는 가운데 사진 영역으로 바뀌고, 나머지 영역까지 다 로딩이 끝나면 최대 콘텐츠풀 페인트 지표가 기록됨

<br />
<br />

##### 12.3.4 기준 점수

- LCP 등의 각종 지표 점수를 측정하는 방법
  > - 직접 자바스크립트 API 를 호출
  > - 도구 활용

<br />

- 최대 콘텐츠풀 페인트 점수 기준
  > - 해당 지표가 2.5초 내로 응답이 오면 좋은 점수
  > - 4초 이내로 응답이 오면 보통
  > - 4초 이상은 나쁨으로 판단

<br />
<br />

##### 12.3.5 개선 방안

- 텍스트는 언제나 옳다

  > - 최대 콘텐츠풀 페인트 지표에서 좋은 점수를 얻는 가장 확실한 방법은 뷰포트 최대 영역, 즉 최대 콘텐츠풀 페인트 예상 영역에 이미지가 아닌 문자열을 넣는 것

<br />

- 이미지 노출 방법별 성능 비교
  > - img 태그: 이미지는 브라우저의 프리로드 스캐너에 의해서 먼저 발견되어 빠르게 요청이 일어남 (프리로드 스캐너란 HTML 을 파싱하는 단계를 차단하지 않고 이미지와 같이 빠르게 미리 로딩하면 좋은 리소스를 먼저 찾아 로딩하는 브라우저의 기능), img 태그 내부의 리소스는 이처럼 HTML 파싱이 미처 완료되지 않더라도 프리로드 스캐너가 병렬적으로 리소스를 다운로드하므로 최대 콘텐츠풀 페인트 요소를 불러오기에 적절한 방법 (picture 태그도 마찬가지)
  > - svg 태그 내부의 img 태그: 모든 리소스를 다 불러온 이후에 이미지를 불러옴, 프리로드 스캐너에 의해 발견되지 않아 병렬적으로 다운로드가 일어나지 않고, 최대 콘텐츠풀 페인트 점수에도 악영향
  > - video 태그의 poster: poster 는 사용자가 video 요소를 재생하거나 탐색하기 전까지 노출되는 요소, 프리로드 스캐너에 의해 조기에 발견되어 img 태그와 같은 성능을 나타냄 (향후에 poster 가 없는 video 의 경우, video 를 실제로 로딩해 첫 번째 프레임을 해당 poster 리소스로 대체할 예정이므로 video 가 최대 콘텐츠풀 페인트에 영향을 받을 것 같다면 poster 를 넣는 것이 좋음)

<br />

- 그 밖에 조심해야 할 사항
  > - 이미지 무손실 압축: 웹으로 서비스할 이미지는 가능한 한 무손실 형식으로 압축해 최소한의 용량으로 서비스하는 것이 좋음
  > - loading=lazy 주의: loading=lazy 는 리소스를 중요하지 않음으로 표시하고 필요할 때만 로드하는 전략, img 태그와 iframe 등에 적용할 수 있지만 최대 콘텐츠풀 콘텐츠의 이미지를 중요하지 않은 리소스로 분류하면 로딩 속도만 늦추고, 지표 점수에 도움이 되지 않음
  > - fadein 과 같은 각종 애니메이션: fadeIn ease 10s 처럼 처리하는 경우 최대 콘텐츠풀 페인트도 그만큼 늦어짐
  > - 클라이언트에서 빌드하지 말 것: 최적의 시나리오는 서버에서 빌드해온 HTML 을 프리로드 스캐너가 바로 읽어서 최대 콘텐츠풀 페인트로 빠르게 가져가는 것, 최대 콘텐츠풀 페인트에 대해 useEffect 코드가 있다면 최대 콘텐츠풀 페인트는 HTML 을 다운로드한 직후가 아니라 리액트 코드를 파싱하고 읽은 후에 API 요청을 보내고 응답을 받으므로 늦어짐 (서버에서 미리 빌드된 채로 오는 것이 좋음)
  > - 최대 콘텐츠풀 리소스는 직접 호스팅: 가능하다면 최대 콘텐츠풀 리소스는 같은 도메인에서 직접 호스팅하는 것이 좋음, 다른 출처에서 정제한 이미지를 가져오는 것은 최적화에 별로 좋은 영향을 미치지 않음

<br />
<br />
<br />

### 12.4 최초 입력 지연 (FID)

##### 12.4.1 정의

- 최초 입력 지연 (FID: First Input Delay)
  > - 웹사이트의 반응성을 측정하는 지표
  > - 사용자가 페이지와 처음 상호 작용을 할 때 (링크를 클릭하거나 버튼을 탭하거나 사용자 지정 JavaScript 기반 컨트롤을 사용할 때) 부터 해당 상호 작용에 대한 응답으로 브라우저가 실제로 이벤트 핸들러 처리를 시작하기까지의 시간을 측정

<br />
<br />

##### 12.4.2 의미

- 화면이 최초에 그려지고 난 뒤, 사용자가 웹페이지에서 클릭 등 사호작용을 수행했을 때 메인 스레드가 해당 이벤트에 대한 반응을 할 수 있을 때까지 걸리는 시간
- 이벤트가 발생하는 시점에 최대한 메인 스레드가 다른 작업을 처리할 수 있도록 여유를 만들어 둬야 사용자에게 빠른 반응성 보장 가능

<br />

- 사용자의 최초 입력
  > - 최초 입력 지연에서는 다양한 이벤트 중에서도 반응성에 해당하는 클릭, 터치, 타이핑 등
  > - 스크롤, 핀치 투 줌 등은 최초 입력 지연 측정 대상에서 제외 (사용자의 입력이 아닌 애니메이션으로 분류)

<br />

- 사용자 경험
  > - Response: 사용자의 입력에 대한 반응 속도, 50 ms 미만으로 이벤트 처리
  > - Animation: 애니메이션의 각 프레임을 10 ms 이하로 생성할 것
  > - Idle: 유휴 시간을 극대화해 페이지가 50 ms 이내에 사용자 입력에 응답하도록 할 것
  > - Load: 5초 이내에 콘텐츠를 전달하고 인터랙션을 준비할 것
  > - 최초 입력 지연은 R 에 해당하는 응답에 초점

<br />
<br />

##### 12.4.3 예제

- 크롬에서 디버깅을 통해 최초 사용자 입력후 지연이 발생하는 웹사이트의 성능 분석 가능
- 이벤트 처리가 얼마나 지연되는지만 판단하는 것이 아니라, 최초 이벤트 발생으로부터 해당 이벤트 핸들러가 실행되는 순간까지 사이의 기간만 측정

<br />
<br />

##### 12.4.4 기준 점수

- 최초 입력 지연 점수 기준
  > - 100 ms 내로 응답이 오면 좋은 점수
  > - 300 ms 이내 응답은 보통
  > - 300 ms 초과는 나쁨으로 처리

<br />
<br />

##### 12.4.5 개선 방안

- 최초 입력 지연을 개선하려면 메인 스레드에 이벤트를 실행할 여유 필요

<br />

- 실행에 오래 걸리는 긴 작업을 분리
  > - 꼭 웹페이지에서 해야 하는 작업이 아니라면 서버에서 처리
  > - 긴 작업을 여러 개로 분리

<br />

- 자바스크립트 코드 최소화
  > - 크롬 개발자 도구 - 커버리지에서 웹페이지를 불러오는 데 사용되지 않는 필요 없는 코드를 확인하고, 급하지 않은 코드는 지연 로딩 기법, 사용자가 필요한 순간에 불러오거나, 우선순위 낮춰서 불러오기
  > - 폴리필 사용 시, 폴리필이 꼭 필요한지 확인 (폴리필 (polypill): 브라우저에서 지원하지 않는 기능을 사용하기 위해 웹페이지에서 직접 구현하고 집어넣는 코드)

<br />

- 타사 자바스크립트 코드 실행의 지연
  > - 타사 스크립트는 대부분 웹페이지 로드에 중요한 자원이 아니므로 script 태그의 async 나 defer 를 이용해 지연 불러오기
  > - defer: script 에 defer 속성이 있다면 먼저 해당 스크립트를 다른 리소스와 함께 병렬로 다운로드, 다운로드하는 중에도 HTML 파싱 등의 메인 스레드 작업은 멈추지 않으므로 다운로드가 완료됐다 하더라도 이 스크립트의 실행은 페이지가 완전히 로딩된 이후에 맨 마지막에 실행
  > - async: script 에 async 속성에 있다면 defer 가 있을 때와 마찬가지로 해당 스크립트를 다른 리소스와 함께 병렬로 다운로드, async 리소스의 다운로드가 완료되면 다른 리소스의 다운로드 완료를 기다리지 않고 바로 실행, async 리소스의 실행 순서는 다운로드가 완료된 순서와 동일
  > - 타사 자바스크립트는 가능하면 async, 더 가능하다면 defer 로 지연하는 것이 좋음
  > - 광고와 같이 실제 사용자의 뷰포트 위치에 따라 불러와야 하는 컴포넌트라면 Intersection Observer 사용

<br />
<br />
<br />

### 12.5 누적 레이아웃 이동 (CLS)

##### 12.5.1 정의

- 누적 레이아웃 이동 (CLS: Cumulative Layout Shift): 페이지의 생명주기 동안 발생하는 모든 예기치 않은 이동에 대한 지표를 계산하는 것, 지표가 낮을 수록 (사용자가 겪는 예상치 못한 레이아웃 이동이 적을수록) 좋은 웹사이트

<br />
<br />

##### 12.5.2 의미

- 누적 레이아웃 이동은 사용자의 가시적인 콘텐츠에 영향을 미쳐야 하기 때문에 뷰포트 내부의 요소에 대해서만 측정
- 최초 렌더링이 시작된 위치에서 레이아웃의 이동이 발생하면 누적 레이아웃 이동 점수로 기록
- 요소가 추가됐더라도 다른 요소의 시작 위치에 영향을 미치지 않았다면 레이아웃 이동으로 간주하지 않음
- 사용자 액션으로 발생한 레이아웃 이동은 점수에 포함하지 않음

<br />

- 점수를 계산할 때 포함되는 내용
  > - 영향분율: 레이아웃 이동이 발생한 요소의 전체 높이와 뷰포트 높이의 비율을 의미 (뷰포트의 높이가 100, 레이아웃 이동이 발생한 요소의 높이가 10, 예기치 않은 레이아웃 이동으로 인해 10 만큼 이동한 경우, 레이아웃 이동으로 잉ㄴ해 총 10 + 10 만큼 뷰포트에 영향을 미쳤으므로 영향분율은 (10 + 10) / 100 = 0.2)
  > - 거리분율: 레이아웃 이동이 발생한 요소가 뷰포트 대비 얼마나 이동했는지 의미 (전체 뷰포트가 100 이고, 예기치 않은 레이아웃 이동으로 인해 10 만큼 이동했다면 거리분율은 10 / 100 = 0.1)
  > - 영향분율과 거리분율을 곱해서 최종 점수 계산

<br />
<br />

##### 12.5.3 예제

- 크롬의 성능 통계에서 페이지가 로딩되는 과정을 통해 레이아웃 이동을 볼 수 있음
- 누적 레이아웃 이동은 기기의 크기에 따라 점수가 다르게 측정될 수 있음 (뷰포트의 높이가 작을수록 조금 더 유리한 점수)
- 노출이 예상되는 부분을 클라이언트에서 HTML 로 자리 잡아두는 것이 누적 레이아웃 지표에 도움
- 홈 화면에 뜨는 배너 광고와 같이 동적으로 결정되는 요소는 서버에서 미리 결정해서 내려오지 않는 경우, 누적 레이아웃 이동을 야기

<br />
<br />

##### 12.5.4 기준 점수

- 누적 레이아웃 이동의 점수 기준
  > - 0.1 이하인 경우 좋은 점수
  > - 0.25 이하인 경우 보통
  > - 0.25 초과는 나쁨

<br />
<br />

##### 12.5.5 개선 방안

- 삽입이 예상되는 요소를 위한 추가적인 공간 확보
  > - useEffect 의 내부에서 요소에 영향을 미치는 작업, 특히 뷰포트 내부에서 노출이 될 확률이 높은 작업 최소화 (useEffect 사용이 불가피하다면 useLayoutEffect 훅 고려)
  > - 스켈레톤 UI 로 동적으로 무언가 뜰 것으로 예상되는 공간 미리 확보
  > - 가장 좋은 방법은 서버 사이드 렌더링

<br />

- 폰트 로딩 최적화
  > - FOUT (Flash of Unstyled Text): HTML 문서에서 지정한 폰트가 보이지 않고 대체 기본 폰트로 보이고 있다가 뒤늦게 폰트가 적용되는 현상
  > - FOIT (Flast of Invisible Text): HTML 문서에서 지정한 폰트가 보이지 않고, 기본 폰트도 없어서 텍스트가 없는 채로 있다가 뒤늦게 폰트가 로딩되면서 페이지에 렌더링되는 현상
  > - link 태그의 preload 사용, font-family 조합으로 누적 레이아웃 이동 최소화 가능

<br />

- 적절한 이미지 크기 설정 (반응형)
  > - width, height 를 원하는 비율로 지정하면 브라우저의 유저 에이전트 스타일시트 (브라우저가 기본으로 제공하는 스타일) 에 포함된 aspect-ratio 속성 덕분에 이미지의 가로세로 비율을 자동으로 맞춰줌
  > - 사용자 뷰포트 너비에 맞춰 다른 이미지를 제공하는 경우, srcset 속성 사용

<br />
<br />

##### 12.5.6 핵심 웹 지표는 아니지만 성능 확인에 중요한 지표들

- 최초 바이트까지의 시간 (Time To First Byte, TTFB)
  > - 브라우저가 웹페이지의 첫 번째 바이트를 수신하는데 걸리는 시간 (페이지를 요청했을 때 요청이 완전히 완료되는 데 걸리는 시간을 측정하는 것이 아니라 최초의 응답이 오는 바이트까지가 얼마나 걸리는지 측정하는 지표)
  > - 600 ms 이상 걸리는 경우 개선 필요
  > - 서버 사이드 렌더링을 수행하고 있다면, 로직과 API 호출을 최적화해서 최초 바이트까지의 시간 개선
  > - 웹페이지의 주요 사용자 국적을 파악해 해당 국적과 가깝게 서버를 위치
  > - 리액트 서버 사이드 렌더링이라면 renderToNodeStream, renderToStaticNodeStream 과 같은 스트리밍 API 를 사용하는 것이 좋음

<br />

- 최초 콘텐츠풀 페인트 (First Contentful Paint, FCP)
  > - 페이지가 로드되기 시작한 시점부터 페이지 콘텐츠의 일부가 화면에 렌더링될 때까지의 시간 측정 (웹사이트에 접속한 순간부터 페이지에 뭐라도 뜨기 시작한 시점까지의 시간)
  > - 1.8 초 이내에 이뤄지면 좋음, 3.0 초 이내는 보통, 그 이후는 개선 필요
  > - 최초 바이트까지의 시간 (TTFB) 부터 개선하면 최초 콘텐츠풀 페인트도 개선
  > - 렌더링을 가로막는 리소스 최소화
  > - Above the Fold 에 대한 최적화, Above the Fold 는 웹에서 최초에 스크롤을 하지 않아도 보이는 영역이지만 최대한 사용자에게 빠르게 보여줘야 하는 영역이므로 게으른 로딩을 하거나 스크립트에 의존해 요소가 렌더링 되는 것을 피해야 최초 콘텐츠풀 페인트 개선에 도움이 됨
  > - 페이지 리다이렉트 최소화
  > - DOM 크기 최소화 (구글 기준, 전체 DOM 노드는 1500 개 미만, 깊이는 32 단계, 부모 노드는 자식 노드를 60 개 정도)
