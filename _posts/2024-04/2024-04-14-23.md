---
title: 모던 리액트 Deep Dive 11장 - Next.js 13 과 리액트 18
categories: [React, Study]
tags: [react, monthlyCs, nextjs]
comment: true
---

<br />

## 11장. Next.js 13 과 리액트 18

- Next.js 버전 13 은 Next.js release 역사를 통틀어 가장 큰 변화가 있는 release
- 리액트 18에서 새롭게 제공하는 서버 컴포넌트와 이를 지원하기 위한 Next.js 13 의 변경 사항
- 레이아웃 지원 시작
- 바벨을 대체할 러스트 (Rust) 기반 SWC 를 뒤이어 웹팩을 대체할 Turbopack 출시

### 11.1 app 디렉터리의 등장

- Next.js 의 아쉬운 점이었던 레이아웃
  > - react-router-dom 을 사용한다면 <Routes> 영역만 각 주소에 맞는 컴포넌트를 선언해서 넣기 가능
  > - Next.js 의 13 버전 이전까지 모든 페이지는 각각의 물리적으로 구별된 파일로 독립
  > - 페이지 공통 레이아웃을 유지할 수 있는 방법은 \_app 이 유일
  > - \_app: 페이지를 초기화하기 위한 용도로 사용, 페이지 변경 시에 유지하고 싶은 레이아웃, 페이지 변경 시 상태 유지, componentDidCatch 를 활용한 에러 핸들링, 페이지간 추가적인 데이터 삽입, global CSS 주입

<br />

- Next.js 의 app 레이아웃

  > - Next.js 13.4.0 버전 미만 사용 시 next.config.js 에서 옵션 활성화 필요

  ```typescript
  /** @type {import('next').NextConfig} */
  const nextConfig = {
    reactStrictMode: true,
    experimental: {
      appDir: true
    }
  };

  module.exports = nextConfig;
  ```

<br />
<br />

##### 11.1.1 라우팅

- /pages 로 정의하던 라우팅 방식이 /app 디렉터리로 이동
- 파일명으로 라우팅하는 것이 불가능

<br />

- 라우팅을 정의하는 법
  > - 기본적으로 Next.js 의 라우팅은 파일 시스템 기반
  > - 새로운 app 기반 라우팅 시스템에서 app 디렉터리 내부의 파일명은 라우팅 명칭에 영향 없음
  > - Next.js 12 이하: /pages/a/b.tsx 또는 /pages/a/b/index/tsx 는 모두 동일한 주소로 변환
  > - Next.js 13 app: /app/a/b 는 /a/b 로 변환되고, 파일명은 무시됨 (폴더명까지 주소로 변환)
  > - Next.js 13 부터는 app 디렉터리 내부의 폴더명이 라우팅, 폴더에 포함될 수 있는 파일명이 제한됨

<br />

- layout.js
  > - layout.js 는 페이지의 기본적인 레이아웃을 구성하는 요소
  > - 해당 폴더에 layout 이 있다면 그 하위 폴더 및 주소에 모두 영향
  > - 루트에는 단 하나의 layout 을 만들 수 있음 (모든 페이지에 영향을 미치는 공통 레이아웃, 공통 레이아웃이 필요하지 않더라도 웹페이지에 필요한 기본 정보만 (html, head 등) 담아두는 것도 유용)
  > - 페이지 하위에 추가되는 layout 은 해당 주소 하위에만 적용
  > - layout 은 주소별 공통 UI 를 포함, \_app 과 \_document 를 대신해 웹페이지를 시작하는 데 필요한 공통 코드를 삽입 가능

<br />

- layout 사용 시 주의할 점
  > - layout 은 app 디렉터리 내부에서 예약어이므로 layout.{js|jsx|ts|tsx} 로 사용, 레이아웃 이외의 다른 목적으로 사용 불가
  > - layout 은 children 을 props 로 받아서 렌더링
  > - layout 내부에는 반드시 export default 로 내보내는 컴포넌트가 있어야 함
  > - layout 내부에서도 API 요청과 같은 비동기 작업을 수행할 수 있음

<br />

- page.js
  > - params: 옵셔널 값, [...id] 와 같은 동적 라우트 파라미터를 사용하는 경우 해당 파라미터에 값이 들어옴
  > - searchParams: URL 에서 ?a=1 과 같은 URLSearchParams 를 의미, layout 에서는 제공되지 않으므로 search parameter 에 의존적인 작업을 해야 한다면 page 내부에서 수행해야 함
  > - layout 과 마찬가지로 page 는 예약어이므로 page.{js|jsx|ts|tsx} 로 사용, export default 로 내보내는 컴포넌트가 있어야 함

<br />

- error.js
  > - 해당 라우팅 영역에서 사용되는 공통 에러 컴포넌트
  > - error.js 를 사용하면 특정 라우팅별로 서로 다른 에러 UI 렌더링이 가능

<br />

- not-found.js
  > - 특정 라우팅 하위의 주소를 찾을 수 없는 404 페이지를 렌더링할 때 사용

<br />

- loading.js
  > - 리액트 Suspense 를 기반으로 해당 컴포넌트가 불러오는 중임을 나타낼 때 사용

<br />

- route.js

  > - /pages/api 에 대한 /app 디렉터리 내부 지원 추가
  >   /pages/api 와 동일하게 /app/api 를 기준으로 디렉터리 라우팅 지원
  > - 파일명에 대한 라우팅이 없어진 것과 마찬가지로 /api 에 대해서도 파일명 라우팅이 없어지고, 그 대신 디렉터리가 라우팅 주소를 담당하며 파일명은 router.js 로 통일
  > - router.js 파일 내부에 REST API 의 get, post 와 같은 메서드명을 예약어로 선언하면 HTTP 요청에 맞게 해당 메서드를 호출

  ```typescript
  // /api/hello/route.ts

  import { NextRequest } from 'next/server';

  export async function GET(request: Request) {}

  export async function POST(request: Request) {}
  ```

<br />
<br />
<br />

### 11.2 리액트 서버 컴포넌트

- 리액트 18에서 새로 도입된 리액트 서버 컴포넌트는 서버 사이드 렌더링과 다른 개념

<br />
<br />

##### 11.2.1 기존 리액트 컴포넌트와 서버 사이드 렌더링의 한계

- 서버 사이드 렌더링의 한계점은
- 자바스크립트 번들 크기가 0인 컴포넌트를 만들 수 없음
- 백엔드 리소스에 대한 직접적인 접근 불가
- 자동 코드 분할 (code split) 불가 (일반적으로 리액트는 lazy 를 사용해서 구현)
- 연쇄적으로 발생하는 클라이언트와 서버의 요청을 대응하기 어려움
- 추상화 비용 증가

<br />
<br />

##### 11.2.2 서버 컴포넌트란?

- 서버 사이드 렌더링, 클라이언트 사이드 렌더링의 장점을 모두 가짐
- 하나의 언어, 하나의 프레임워크, 하나의 API 와 개념을 사용하면서 서버와 클라이언트 모두에서 컴포넌트를 렌더링할 수 있는 기법
- 서버에서 할 수 있는 일은 서버가 처리, 서버가 할 수 없는 나머지 작업은 클라이언트인 브라우저에서 수행 (일부 컴포넌트는 클라이언트에서, 일부 컴포넌트는 서버에서 렌더링)
- 클라이언트 컴포넌트는 서버 컴포넌트를 import 할 수 없음
- 서버 컴포넌트의 이론에 따르면 모든 컴포넌트는 서버 컴포넌트가 될 수도 있고 클라이언트 컴포넌트가 될 수도 있음

<br />

- 서버 컴포넌트
  > - 요청이 오면 그 순간 서버에서 딱 한 번 실행될 뿐이므로 상태를 가질 수 없음, 따라서 리액트에서 상태를 가질 수 있는 useState, useReducer 등의 훅을 사용할 수 없음
  > - 렌더링 생명 주기도 사용할 수 없음, 한번 렌더링되면 끝이므로 useEffect, useLayoutEffect 사용 불가
  > - 앞의 두 가지 제약사항으로 읺애 effect 나 state 에 의존하는 사용자 정의 훅 또한 사용할 수 없음, 다만 effect 나 state 에 의존하지 않고 서버에서 제공할 수 있는 기능ㅁ안 사용하는 훅이라면 충분히 사용 가능
  > - 브라우저에서 실행되지 않고 서버에서만 실행되기 때문에 DOM API 를 쓰거나 window, document 등에 접근할 수 없음
  > - 데이터베이스, 내부 서비스, 파일 시스템 등 서버에만 있는 데이터를 async / await 로 접근할 수 있음, 컴포넌트 자체가 async 한 것이 가능
  > - 다른 서버 컴포넌트를 렌더링하거나 div, span, p 같은 요소를 렌더링하거나 클라이언트 컴포넌트를 렌더링할 수 있음

<br />

- 클라이언트 컴포넌트
  > - 브라우저 환경에서만 실행되므로 서버 컴포넌트를 불러오거나, 서버 전용 훅이나 유틸리티를 불러올 수 없음
  > - 서버 컴포넌트가 클라이언트 컴포넌트를 렌더링하고, 클라이언트 컴포넌트가 자식으로 서버 컴포넌트를 갖는 구조 가능
  > - 앞의 두 가지 예외 사항을 제외하면 일반적으로 우리가 알고 있는 리액트 컴포넌트와 동일 (state, effect 를 사용할 수 있으며 브라우저 API 도 사용할 수 있음)
  > - 리액트는 모든 컴포넌트를 공용 컴포넌트로 판단 (서버에서 실행 가능 한 것으로 분류) 하므로, 클라이언트 컴포넌트를 명시적으로 선언하려면 파일의 맨 첫 줄에 "use client" 를 작성

<br />

- 공용 컴포넌트 (shared components)
  > - 서버와 클라이언트에서 모두 사용 가능, 공통으로 사용할 수 있는 만큼 서버 컴포넌트와 클아이언트 컴포넌트의 모든 제약을 받음

<br />
<br />

##### 11.2.3 서버 사이드 렌더링과 서버 컴포넌트의 차이

- 서버 사이드 렌더링
  > - 응답받은 페이지 전체를 HTML 로 렌더링하는 과정을 서버에서 수행한 후, 그 결과를 클라이언트에 내려주고, 클라이언트에서 하이드레이션 과정을 거쳐 서버의 결과물을 확인하고 이벤트를 붙이등는 등의 작업 수행
  > - 서버 사이드 렌더링의 목적은 초기에 인터랙션은 불가하지만 정적인 HTML 을 빠르게 내려주는 것 (여전히 초기 HTML 이 로딩된 이후에는 클라이언트에서 자바스크립트 코드를 다운로드하고, 파싱하고, 실행하는 데 비용 발생)

<br />

- 서버 사이드 렌더링과 서버 컴포넌트를 모두 채택한다면?
  > - 서버 컴포넌트를 활용해 서버에서 렌더링할 수 있는 컴포넌트는 서버에서 완성해서 제공받은 다음, 클라이언트 컴포넌트는 서버 사이드 렌더링으로 초기 HTML 을 빠르게 전달받을 수 있음
  > - 두 가지 방법을 결합하면 클라이언트 및 서버 컴포넌트를 모두 빠르게 보여줄 수 있고, 동시에 클라이언트에서 내려받아야 하는 자바스크립트의 양도 줄어기 때문에 브라우저 부담을 줄일 수 있음

<br />
<br />

##### 11.2.4 서버 컴포넌트는 어떻게 작동하는가?

- 서버가 렌더링 요청을 받음
  > - 서버가 렌더링 과정을 수행해야 하므로 리갱트 서버 컴포넌트를 사용하는 모든 페이지는 항상 서버에서 시작됨, 루트에 있는 컴포넌트는 항상 서버 컴포넌트

<br />

- 서버는 받은 요청에 따라 컴포넌트를 JSON 으로 직렬화 (serialize)
  > - 서버에서 렌더링할 수 있는 것은 직렬화해서 내보내고, 클라이언트 컴포넌트로 표시된 부분은 해당 공간을 플레이스 홀더 형식으로 비워두고 나타냄
  > - 브라우저는 이후에 이 결과물을 받아서 다시 역직렬화한 다음 렌더링 수행

<br />

- 브라우저가 리액트 컴포넌트 트리를 구성
  > - 브라우저가 서버로 JSON 결과물을 받았다면 이 구문을 다시 파싱한 결과물을 바탕으로 트리를 재구성
  > - M1 과 같은 형태의 클라이언트 컴포넌트를 받았다면 클라이언트에서 렌더링을 진행, 서버에서 만들어진 결과물을 받았다면 이 정보를 기반으로 리액트 트리를 구성
  > - 트리를 렌더링해서 브라우저의 DOM 에 커밋

<br />

- 리액트 서버 컴포넌트 작동 방식의 특별한 점
  > - 서버에서 클라이언트로 정보를 보낼 때 스트리밍 형태로 보냄, 클라이언트가 줄 단위로 JSON 을 읽고 컴포넌트를 렌더링할 수 있어 브라우저에서는 되도록 빨리 사용자에게 결과물을 보여줄 수 있다는 장점이 있음
  > - 컴포넌트들이 하나의 번들러 작업에 포함돼 있지 않고 각 컴포넌트별로 번들링이 별개로 돼 있어 필요에 따라 컴포넌트를 지연해서 받거나 따로 받는 등의 작업이 가능
  > - 서버 사이드 렌더링과는 다르게 결과물이 HTML 이 아닌 JSON 형태, 리액트 컴포넌트 트리의 구성을 최대한 빠르게 할 수 있도록 함

<br />
<br />
<br />

### 11.3 Next.js 에서의 리액트 서버 컴포넌트

- Next.js 13 버전에 서버 컴포넌트 도입
- 기본적인 서버 컴포넌트의 제약은 동일 (서버 컴포넌트는 클라이언트 컴포넌트를 불러올 수 없고, 클아이언트 컴포넌트는 서버 컴포넌트를 children props 로 받는 것만 가능)
- Next.js 의 루트 컴포넌트는 각 페이지에 존재하는 page.js
- layout.js 도 서버 컴포넌트로 작동

<br />
<br />

##### 11.3.1 새로운 fetch 도입과 getServerSideProps, getStaticProps, getInitialProps 의 삭제

- getServerSideProps, getStaticProps, getInitialProps 의 삭제
  > - 대신 모든 데이터 요청은 웹에서 제공하는 표준 API 인 fetch 를 기반으로 이루어짐
  > - getServerSideProps 의 삭제로 서버에서 데이터를 직접 불러오기 가능, 컴포넌트가 비동기적으로 작동하는 것도 가능

<br />
<br />

##### 11.3.2 정적 렌더링과 동적 렌더링

- Next.js 13 에서의 정적 라우팅: 기본적으로 빌드 타임에 렌더링을 미리 해두고, 캐싱해서 재사용할 수 있게 함
- Next.js 13 에서의 동적 라우팅: 서버에 매번 요청이 올 때마다 컴포넌트를 렌더링하도록 변경

<br />
<br />

##### 11.3.3 캐시와 mutating, 그리고 revalidating

- Next.js 는 fetch 의 기본 작동을 재정의해 {next: {revalidate?: number | false}} 를 제공, 이를 바탕으로 해당 데이터의 유효한 시간을 정해두고 이 시간이 지나면 다시 데이터를 불러와서 페이지를 렌더링하는 것이 가능
- 페이지에 revalidate 라를 변수를 선언해서 페이지 레벨로 정의하는 것도 가능

  ```typescript
  // app/page.tsx

  export const revalidate = 60;
  ```

<br />

- 캐시와 갱신이 이루어지는 과정
  > - 최초로 해당 라우트로 요청이 올 때는 미리 정적으로 캐시해 둔 데이터를 보여줌
  > - 이 캐시된 초기 요청은 revalidate 에 선언된 값만큼 유지
  > - 만약 해당 시간이 지나도 일단 캐시된 데이터를 보여줌
  > - Next.js 는 캐시된 데이터를 보여주는 한편, 시간이 경과했으므로 백그라운드에서 다시 데이터를 불러옴
  > - 앞의 작업이 성공적으로 끝나면 캐시된 데이터를 갱신하고, 그렇지 않으면 과거 데이터를 보여줌

<br />

- router.refresh()
  > - 캐시를 전체적으로 무효화하고 싶을 때 사용
  > - 브라우저의 히스토리에 영향을 미치지 않고, 서버에서 루트부터 데이터를 전체적으로 가져와서 갱신
  > - 브라우저나 리액트의 state 에는 영향을 미치지 않음

<br />
<br />

##### 11.3.4 스트리밍을 활용한 점진적인 페이지 불러오기

- 스트리밍
  > - HTML 을 작은 단위로 쪼개서 완성되는 대로 클라이언트로 점진적으로 보내기 때문에 모든 데이터가 로드될 때까지 기다리지 않더라도 먼저 데이터가 로드되는 컴포넌트를 빠르게 보여줄 수 있음
  > - 경로에 loading.tsx 를 배치함으로써 자동으로 Suspense 가 되도록 하거나 Suspense 를 직접 배치해서 스트리밍 활용 가능

<br />
<br />
<br />

### 11.4 웹팩의 대항마, 터보팩의 등장 (beta)

- 터보팩
  > - Rust 기반으로 작성
  > - 웹팩 대비 최대 700배, Vite 대비 최대 10배가 빠름

<br />
<br />
<br />

### 11.5 서버 액션 (alpha)

- API 를 굳이 생성하지 않아도 함수 수준에서 서버에 직접 접근해 데이터 요청 등을 수행할 수 있는 기능
- 서버 컴포넌트와 다르게, 특정 함수 실행 그 자체만을 서버에서 수행할 수 있다는 장점이 있음
- next.config.js 에서 옵션 활성화 필요
- 함수 내부 또는 파일 상단에 클라이언트 선언과 비슷하게 "user server" 지시자 선언 필요
- 함수는 반드시 async

```typescript
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    serverActions: true
  }
};

module.exports = nextConfig;
```

```typescript
async function serverAction() {
  'use server';
}
```

<br />

- 서버 액션이 수행할 수 있는 작업
  > - form 의 action
  > - input 의 submit 과 image 의 formAction
  > - startTransition 과의 연동
  > - server mutation 이 없는 작업

<br />

- 서버 액션 사용 시 주의할 점
  > - 서버 액션은 클라이언트 컴포넌트 내에서 정의될 수 없음
  > - 서버 액션을 import 하는 것뿐만 아니라, props 형태로 서버 액션을 클라이언트 컴포넌트에 넘기는 것 또한 가능
